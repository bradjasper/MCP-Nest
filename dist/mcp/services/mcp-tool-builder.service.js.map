{"version":3,"file":"mcp-tool-builder.service.js","sourceRoot":"","sources":["../../../src/mcp/services/mcp-tool-builder.service.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,2CAA4D;AAC5D,6BAAwB;AAKxB,iEAA4D;AAE5D,oEAA8D;AAOjD,QAAA,0BAA0B,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC;AAOzE,MAAM,cAAc,GAAG,IAAI,GAAG,EAA2C,CAAC;AAkCnE,IAAM,cAAc,sBAApB,MAAM,cAAc;IAGzB,YACmB,QAA4B,EACH,WAAmB,EACrB,OAAmB;QAF1C,aAAQ,GAAR,QAAQ,CAAoB;QACH,gBAAW,GAAX,WAAW,CAAQ;QACrB,YAAO,GAAP,OAAO,CAAY;QAE3D,IAAI,CAAC,MAAM,GAAG,IAAA,oCAAe,EAAC,gBAAc,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAEjE,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC;YACrC,cAAc,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;QAC7C,CAAC;IACH,CAAC;IAuBD,YAAY,CAAC,UAAiC;QAC5C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,6BAA6B,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;QAGlE,MAAM,cAAc,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAE,CAAC;QAC7D,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,OAAO,CAAC,CAAC;QAGxD,MAAM,UAAU,GAAG,UAAU,CAAC,UAAU,IAAI,OAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAGzD,MAAM,QAAQ,GAAiB;YAC7B,IAAI,EAAE,UAAU,CAAC,IAAI;YACrB,WAAW,EAAE,UAAU,CAAC,WAAW;YACnC,UAAU;YACV,YAAY,EAAE,UAAU,CAAC,YAAY;YACrC,WAAW,EAAE,UAAU,CAAC,WAAW;YACnC,KAAK,EAAE,UAAU,CAAC,KAAK;YACvB,QAAQ,EAAE,UAAU,CAAC,QAAQ;YAC7B,cAAc,EAAE,UAAU,CAAC,cAAc;YACzC,aAAa,EAAE,UAAU,CAAC,aAAa;SACxC,CAAC;QAGF,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,EAAE;YAClD,IAAI,EAAE,MAAM;YACZ,QAAQ;YACR,aAAa,EAAE,kCAA0B;YACzC,UAAU,EAAE,UAAU,CAAC,IAAI;SAC5B,CAAC,CAAC;IACL,CAAC;IASD,UAAU,CAAC,QAAgB;QACzB,OAAO,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;IAC7D,CAAC;IAWD,MAAM,CAAC,oBAAoB,CACzB,WAAmB,EACnB,QAAgB;QAEhB,OAAO,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;IACxD,CAAC;CACF,CAAA;AA9FY,wCAAc;yBAAd,cAAc;IAD1B,IAAA,mBAAU,GAAE;IAMR,WAAA,IAAA,eAAM,EAAC,eAAe,CAAC,CAAA;IACvB,WAAA,IAAA,eAAM,EAAC,aAAa,CAAC,CAAA;qCAFK,yCAAkB;GAJpC,cAAc,CA8F1B","sourcesContent":["import { Injectable, Inject, Logger } from '@nestjs/common';\nimport { z } from 'zod';\nimport {\n  DynamicToolDefinition,\n  DynamicToolHandler,\n} from '../interfaces/dynamic-tool.interface';\nimport { McpRegistryService } from './mcp-registry.service';\nimport type { McpOptions } from '../interfaces';\nimport { createMcpLogger } from '../utils/mcp-logger.factory';\nimport { ToolMetadata } from '../decorators/tool.decorator';\n\n/**\n * Symbol used to identify dynamic tools in the registry.\n * When a tool's providerClass equals this token, it's a dynamic tool.\n */\nexport const DYNAMIC_TOOL_HANDLER_TOKEN = Symbol('DYNAMIC_TOOL_HANDLER');\n\n/**\n * Global map of dynamic tool handlers, scoped by moduleId.\n * Using a module-level Map ensures handlers persist across different\n * McpToolBuilder instances that may be created by the DI container.\n */\nconst globalHandlers = new Map<string, Map<string, DynamicToolHandler>>();\n\n/**\n * Service for programmatically registering MCP tools at runtime.\n *\n * Use this to register tools with descriptions/parameters from databases\n * or other dynamic sources during application bootstrap.\n *\n * @example\n * ```typescript\n * @Injectable()\n * export class DynamicToolsService implements OnModuleInit {\n *   constructor(\n *     private readonly toolBuilder: McpToolBuilder,\n *     private readonly dbService: DatabaseService,\n *   ) {}\n *\n *   async onModuleInit() {\n *     const collections = await this.dbService.getCollections();\n *\n *     this.toolBuilder.registerTool({\n *       name: 'search-knowledge',\n *       description: `Search collections: ${collections.join(', ')}`,\n *       parameters: z.object({ query: z.string() }),\n *       handler: async (args, context) => {\n *         const results = await this.dbService.search(args.query);\n *         return { content: [{ type: 'text', text: JSON.stringify(results) }] };\n *       },\n *     });\n *   }\n * }\n * ```\n */\n@Injectable()\nexport class McpToolBuilder {\n  private readonly logger: Logger;\n\n  constructor(\n    private readonly registry: McpRegistryService,\n    @Inject('MCP_MODULE_ID') private readonly mcpModuleId: string,\n    @Inject('MCP_OPTIONS') private readonly options: McpOptions,\n  ) {\n    this.logger = createMcpLogger(McpToolBuilder.name, this.options);\n    // Initialize handler map for this module if it doesn't exist\n    if (!globalHandlers.has(mcpModuleId)) {\n      globalHandlers.set(mcpModuleId, new Map());\n    }\n  }\n\n  /**\n   * Register a dynamic tool for the current MCP server.\n   *\n   * Tools registered here will appear in the `tools/list` response and\n   * can be called via `tools/call` just like decorator-based tools.\n   *\n   * @param definition - The tool definition including name, description, parameters, and handler\n   *\n   * @example\n   * ```typescript\n   * toolBuilder.registerTool({\n   *   name: 'search-knowledge',\n   *   description: await getDescriptionFromDB(),\n   *   parameters: z.object({ query: z.string() }),\n   *   handler: async (args, context) => {\n   *     const results = await searchService.search(args.query);\n   *     return { content: [{ type: 'text', text: JSON.stringify(results) }] };\n   *   },\n   * });\n   * ```\n   */\n  registerTool(definition: DynamicToolDefinition): void {\n    this.logger.debug(`Registering dynamic tool: ${definition.name}`);\n\n    // Store the handler for later execution (scoped by moduleId)\n    const moduleHandlers = globalHandlers.get(this.mcpModuleId)!;\n    moduleHandlers.set(definition.name, definition.handler);\n\n    // Default to empty object schema if no parameters provided (matches @Tool decorator behavior)\n    const parameters = definition.parameters ?? z.object({});\n\n    // Build metadata matching ToolMetadata interface\n    const metadata: ToolMetadata = {\n      name: definition.name,\n      description: definition.description,\n      parameters,\n      outputSchema: definition.outputSchema,\n      annotations: definition.annotations,\n      _meta: definition._meta,\n      isPublic: definition.isPublic,\n      requiredScopes: definition.requiredScopes,\n      requiredRoles: definition.requiredRoles,\n    };\n\n    // Register with the registry\n    this.registry.registerDynamicTool(this.mcpModuleId, {\n      type: 'tool',\n      metadata,\n      providerClass: DYNAMIC_TOOL_HANDLER_TOKEN,\n      methodName: definition.name,\n    });\n  }\n\n  /**\n   * Get the handler function for a dynamic tool.\n   * Used internally by McpToolsHandler to execute dynamic tools.\n   *\n   * @param toolName - The name of the tool\n   * @returns The handler function, or undefined if not found\n   */\n  getHandler(toolName: string): DynamicToolHandler | undefined {\n    return globalHandlers.get(this.mcpModuleId)?.get(toolName);\n  }\n\n  /**\n   * Get the handler function for a dynamic tool by module ID.\n   * Static method used when the module ID is known but the correct\n   * McpToolBuilder instance may not be available.\n   *\n   * @param mcpModuleId - The module ID to look up handlers for\n   * @param toolName - The name of the tool\n   * @returns The handler function, or undefined if not found\n   */\n  static getHandlerByModuleId(\n    mcpModuleId: string,\n    toolName: string,\n  ): DynamicToolHandler | undefined {\n    return globalHandlers.get(mcpModuleId)?.get(toolName);\n  }\n}\n"]}