{"version":3,"file":"mcp-options.interface.js","sourceRoot":"","sources":["../../../src/mcp/interfaces/mcp-options.interface.ts"],"names":[],"mappings":";;;AAIA,IAAY,gBAIX;AAJD,WAAY,gBAAgB;IAC1B,+BAAW,CAAA;IACX,uDAAmC,CAAA;IACnC,mCAAe,CAAA;AACjB,CAAC,EAJW,gBAAgB,gCAAhB,gBAAgB,QAI3B","sourcesContent":["import { ServerCapabilities } from '@modelcontextprotocol/sdk/types.js';\nimport { CanActivate, ModuleMetadata, Type } from '@nestjs/common';\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\n\nexport enum McpTransportType {\n  SSE = 'sse',\n  STREAMABLE_HTTP = 'streamable-http',\n  STDIO = 'stdio',\n}\n\nexport interface McpOptions {\n  // When and if, additional properties are introduced in ServerOptions or ServerInfo,\n  // consider deprecating these fields in favor of using ServerOptions and ServerInfo directly.\n  name: string;\n  version: string;\n  capabilities?: ServerCapabilities;\n  instructions?: string;\n\n  transport?: McpTransportType | McpTransportType[];\n  serverMutator?: (server: McpServer) => McpServer;\n  sseEndpoint?: string;\n  messagesEndpoint?: string;\n  mcpEndpoint?: string;\n  /**\n   * @deprecated Use `app.setGlobalPrefix()` for global api prefix. Use apiPrefix to attach a prefix to the handshake.\n   */\n  globalApiPrefix?: never;\n  apiPrefix?: string;\n  guards?: Type<CanActivate>[];\n  /**\n   * Allow unauthenticated sessions to connect and access @PublicTool() tools.\n   *\n   * When true (freemium mode):\n   * - Unauthenticated requests are allowed through guards\n   * - Can access tools marked with @PublicTool()\n   * - Must authenticate to access protected tools (based on scopes/roles)\n   *\n   * When false or undefined (standard OAuth flow - default):\n   * - Unauthenticated requests receive 401 response\n   * - Triggers MCP OAuth authorization flow\n   * - All tools require authentication\n   *\n   * @default false\n   */\n  allowUnauthenticatedAccess?: boolean;\n  decorators?: ClassDecorator[];\n  sse?: {\n    pingEnabled?: boolean;\n    pingIntervalMs?: number;\n  };\n  streamableHttp?: {\n    enableJsonResponse?: boolean;\n    sessionIdGenerator?: () => string;\n    /**\n     * @experimental: The current implementation does not fully comply with the MCP Specification.\n     */\n    statelessMode?: boolean;\n  };\n  /**\n   * Configure logging for the MCP module.\n   * - `false` to disable all MCP logging\n   * - `{ level: LogLevel[] }` to specify which log levels to show\n   * - `undefined` (default) to use standard NestJS logging\n   */\n  logging?:\n    | false\n    | {\n        level: ('log' | 'error' | 'warn' | 'debug' | 'verbose')[];\n      };\n}\n\n// Async variant omits transport since controllers are not auto-registered in forRootAsync\nexport type McpAsyncOptions = Omit<McpOptions, 'transport'>;\n\nexport interface McpOptionsFactory {\n  createMcpOptions(): Promise<McpAsyncOptions> | McpAsyncOptions;\n}\n\nexport interface McpModuleAsyncOptions extends Pick<ModuleMetadata, 'imports'> {\n  useExisting?: Type<McpOptionsFactory>;\n  useClass?: Type<McpOptionsFactory>;\n  useFactory?: (...args: any[]) => Promise<McpAsyncOptions> | McpAsyncOptions;\n  inject?: any[];\n  extraProviders?: any[]; // allow user to provide additional providers in async mode\n}\n"]}