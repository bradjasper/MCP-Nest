{"version":3,"file":"dynamic-tool.interface.js","sourceRoot":"","sources":["../../../src/mcp/interfaces/dynamic-tool.interface.ts"],"names":[],"mappings":"","sourcesContent":["import { z } from 'zod';\nimport { Context } from './mcp-tool.interface';\nimport { ToolAnnotations } from '../decorators/tool.decorator';\n\n/**\n * Handler function signature for dynamically registered tools.\n * Receives the same arguments as decorator-based tools.\n */\nexport type DynamicToolHandler = (\n  args: Record<string, unknown>,\n  context: Context,\n  request: any,\n) => Promise<any> | any;\n\n/**\n * Definition for a dynamically registered tool.\n * Use this with McpToolBuilder.registerTool() to register tools at runtime.\n *\n * @example\n * ```typescript\n * toolBuilder.registerTool({\n *   name: 'search-knowledge',\n *   description: 'Search the knowledge base',\n *   parameters: z.object({ query: z.string() }),\n *   handler: async (args, context) => {\n *     const results = await searchService.search(args.query);\n *     return { content: [{ type: 'text', text: JSON.stringify(results) }] };\n *   },\n * });\n * ```\n */\nexport interface DynamicToolDefinition {\n  /** Unique name for the tool */\n  name: string;\n  /** Description shown to the LLM */\n  description: string;\n  /** Zod schema for input validation */\n  parameters?: z.ZodType;\n  /** Zod schema for output validation */\n  outputSchema?: z.ZodType;\n  /** MCP tool annotations */\n  annotations?: ToolAnnotations;\n  /** Additional metadata */\n  _meta?: Record<string, any>;\n  /** Handler function that executes the tool */\n  handler: DynamicToolHandler;\n  /** Mark as public (accessible without authentication) */\n  isPublic?: boolean;\n  /** Required OAuth scopes */\n  requiredScopes?: string[];\n  /** Required user roles */\n  requiredRoles?: string[];\n}\n"]}